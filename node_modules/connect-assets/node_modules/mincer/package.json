{
  "name": "mincer",
  "version": "1.2.2",
  "description": "Web assets processor. Native JavaScript port of Sprockets.",
  "keywords": [
    "sprockets",
    "assets",
    "minify",
    "uglify",
    "bundle",
    "less",
    "stylus"
  ],
  "homepage": "https://github.com/nodeca/mincer",
  "author": {
    "name": "Aleksey V Zapparov",
    "email": "ixti@member.fsf.org",
    "url": "http://ixti.net/"
  },
  "bugs": {
    "url": "https://github.com/nodeca/mincer/issues"
  },
  "license": {
    "type": "MIT",
    "url": "https://github.com/nodeca/mincer/blob/master/LICENSE"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/nodeca/mincer.git"
  },
  "main": "./index.js",
  "bin": {
    "mincer": "bin/mincer.js"
  },
  "scripts": {
    "test": "make test"
  },
  "dependencies": {
    "argparse": "~ 0.1.16",
    "fs-tools": "~ 0.2.11",
    "hike": "~ 1.0.0",
    "lodash": "~ 2.4.1",
    "mimoza": "~ 0.3.0",
    "pako": "~ 0.2.5",
    "shellwords": "~ 0.1.0",
    "source-map": "~ 0.1.40"
  },
  "devDependencies": {
    "eslint": "0.10.2",
    "eslint-plugin-nodeca": "~1.0.3",
    "mocha": "*",
    "autoprefixer-core": "*",
    "coffee-script": "*",
    "connect": "*",
    "csso": "*",
    "csswring": "*",
    "ejs": "*",
    "jade": "*",
    "less": "*",
    "node-sass": "*",
    "stylus": "*",
    "uglify-js": "*"
  },
  "readme": "Mincer - assets processor\n=========================\n\n[![Build Status](https://travis-ci.org/nodeca/mincer.svg?branch=master)](https://travis-ci.org/nodeca/mincer)\n[![NPM version](https://img.shields.io/npm/v/mincer.svg)](https://www.npmjs.org/package/mincer)\n\nJavaScript port of Sprockets (v2.10.0). It features same declarative dependency\nmanagement (with exactly same language) for CSS and JavaScript and preprocessor\npipeline. Mincer allows you to write assets in the languages like: CoffeeScript,\nLESS, Stylus and others. Moreover mincer has advanced built-in features, not\navailable in sprockets:\n\n- sourcemaps support\n- macros support (nice alternative to EJS)\n\nSee [Sprockets](https://github.com/sstephenson/sprockets),\n[Mincer API Documentation](http://nodeca.github.io/mincer/) and\n[Mincer examples](https://github.com/nodeca/mincer/tree/master/examples)\nfor more details.\n\nSupported engines are described in [Wiki](https://github.com/nodeca/mincer/wiki).\nIf you wish to add new engine support - read\n[tutorial](https://github.com/nodeca/mincer/wiki/How-to-create-addon). Also\nyou can [search existing extentions](https://www.npmjs.org/browse/keyword/mincer-contrib)\nin npm.\n\n\n## Notice on upgrade 1.1.x -> 1.2.x\n\nUpdate dependencies in your project, if use these:\n\n- replace `autoprefixer` -> `autoprefixer-core`\n- upgrade `csswring` 1.x -> 2.x\n\n\n## Installation\n\nInstall Mincer from npm registry:\n\n    $ npm install mincer\n\nOr install bleeding edge version from GitHub repo:\n\n    $ npm install git://github.com/nodeca/mincer.git\n\n\n## Using Mincer from CLI\n\nTo use Mincer from CLI, you will need to install it globally:\n\n    $ npm install mincer -g\n\nUsage is really simple (see `mincer -h` for details):\n\n    $ mincer --include assets/javascripts \\\n             --include assets/stylesheets \\\n             --output public/assets \\\n             application.js application.css\n\nIf you are using mincer CLI often, you would probably want to \"preset\" some of\nthe options/arguments for your project. Just create `.mincerrc` file and put\nargument you want in it. For example:\n\n    --include assets/javascripts --include assets/stylesheets --output public/assets\n\n\n## Understanding the Mincer Environment\n\nYou'll need an instance of the `Mincer.Environment` class to\naccess and serve assets from your application.\n\nThe `Environment` has methods for retrieving and serving assets, manipulating\nthe load path, and registering processors. It is also used by `Mincer.Server`\nwhich can be mounted directly as `request` event handler of `http.Server` or\nas `connect` middleware.\n\n\n### The Load Path\n\nThe *load paths* is an ordered list of directories that Mincer uses to search\nfor assets.\n\nIn the simplest case, a Mincers environment's load path will consist\nof a single directory containing your application's asset source\nfiles. When mounted, server will serve assets from this directory as if\nthey were static files in your public root.\n\nThe power of the load path is that it lets you organize your source\nfiles into multiple directories -- even directories that live outside\nyour application -- and combine those directories into a single\nvirtual filesystem. That means you can easily bundle JavaScript, CSS\nand images into a library and import them into your application.\n\n\n#### Manipulating the Load Path\n\nTo add a directory to your environment's load path, use the `appendPath` and\n`prependPath` methods. Directories at the beginning of the load path have\nprecedence over subsequent directories.\n\n``` javascript\nenvironment = new Mincer.Environment();\nenvironment.appendPath('app/assets/javascripts');\nenvironment.appendPath('lib/assets/javascripts');\nenvironment.appendPath('vendor/assets/jquery');\n```\n\nIn general, you should append to the path by default and reserve\nprepending for cases where you need to override existing assets.\n\n\n### Accessing Assets\n\nOnce you've set up your environment's load path, you can mount the\nenvironment as a server and request assets via HTTP. You can also\naccess assets programmatically from within your application.\n\n\n#### Logical Paths\n\nAssets in Mincer are always referenced by their *logical path*.\n\nThe logical path is the path of the asset source file relative to its\ncontaining directory in the load path. For example, if your load path\ncontains the directory `app/assets/javascripts`:\n\n<table>\n  <tr>\n    <th>Asset source file</th>\n    <th>Logical path</th>\n  </tr>\n  <tr>\n    <td>app/assets/javascripts/application.js</td>\n    <td>application.js</td>\n  </tr>\n  <tr>\n    <td>app/assets/javascripts/models/project.js</td>\n    <td>models/project.js</td>\n  </tr>\n</table>\n\nIn this way, all directories in the load path are merged to create a\nvirtual filesystem whose entries are logical paths.\n\n\n#### Serving Assets Over HTTP\n\nWhen you mount an environment, all of its assets are accessible as\nlogical paths underneath the *mount point*. For example, if you mount\nyour environment at `/assets` and request the URL `/assets/application.js`,\nMincer will search your load path for the file named `application.js`\nand serve it.\n\n``` javascript\nvar connect = require('connect');\nvar Mincer  = require('mincer');\n\nvar environment = new Mincer.Environment();\nenvironment.appendPath('app/assets/javascripts');\nenvironment.appendPath('app/assets/stylesheets');\n\nvar app = connect();\napp.use('/assets', Mincer.createServer(environment));\napp.use(function (req, res) {\n  // your application here...\n});\n```\n\n\n#### Accessing Assets Programmatically\n\nYou can use the `findAsset` method to retrieve an asset from a Mincers\nenvironment. Pass it a logical path and you'll get a `BundledAsset`\ninstance back.\n\nCall `toString` on the resulting asset to access its contents, `length` to\nget its length in bytes, `mtime` to query its last-modified time, and\n`pathname` to get its full path on the filesystem.\n\n``` javascript\nvar asset = environment.findAsset('application.js');\n\nasset.toString(); // resulting contents\nasset.length;     // length in bytes\nasset.mtime;      // last modified time\nasset.pathname;   // full path on the filesystem\n```\n\n\n## Using Engines\n\nAsset source files can be written in another language, like Stylus or\nCoffeeScript, and automatically compiled to CSS or JavaScript by\nMincer. Compilers for these languages are called *engines*.\n\nEngines are specified by additional extensions on the asset source\nfilename. For example, a CSS file written in Stylus might have the name\n`layout.css.styl`, while a JavaScript file written in CoffeeScript\nmight have the name `dialog.js.coffee`.\n\n\n### Styling with Stylus\n\n[Stylus](http://learnboost.github.com/stylus/) is a revolutionary new language,\nproviding an efficient, dynamic, and expressive way to generate CSS. Supporting\nboth an indented syntax and regular CSS style.\n\nIf the `stylus` Node module is available to your application, you can use Stylus\nto write CSS assets in Mincer. Use the extension `.css.styl`.\n\n\n### Styling with LESS\n\n[LESS](http://lesscss.org/) extends CSS with dynamic behavior such as\nvariables, mixins, operations and functions.\n\nIf the `less` Node module is available to your application, you can use LESS\nto write CSS assets in Mincer. Use the extension `.css.less`.\n\n\n### Styling with Sass\n\n[Sass](http://sass-lang.com/) is an extension of CSS3, adding nested rules, \nvariables, mixins, selector inheritance, and more.\n\nIf the `node-sass` Node module is available to your application, you can use Sass\nto write CSS assets in Mincer. Use the extension `.css.sass` or `.css.scss`.\n\n\n### Scripting with CoffeeScript\n\n[CoffeeScript](http://jashkenas.github.com/coffee-script/) is a\nlanguage that compiles to the \"good parts\" of JavaScript, featuring a\ncleaner syntax with array comprehensions, classes, and function\nbinding.\n\nIf the `coffee-script` Node module is available to your application, you can use\nCoffeeScript to write JavaScript assets in Mincer.\nUse the extension `.js.coffee`.\n\n\n### JavaScript Templating with Haml Coffee\n\nMincer supports JavaScript templates for client-side rendering of strings or\nmarkup. JavaScript templates have the special format extension `.jst` and are\ncompiled to JavaScript functions.\n\nWhen loaded, a JavaScript template function can be accessed by its logical path\nas a property on the global `JST` object. Invoke a template function to render\nthe template as a string. The resulting string can then be inserted into the DOM.\n\n```\n// templates/hello.jst.hamlc\n%div= Hello, %span= #{ @name }!\n```\n\n``` javascript\n// application.js\n//= require templates/hello\n$(\"#hello\").html(JST[\"templates/hello\"]({ name: \"Sam\" }));\n```\n\nMincer supports two template languages: [Haml Coffee][hamlc] and [Jade][jade].\n\nIf `coffee-script` and `haml-coffee` are available to your application, you can\nuse _Haml Cofee_ templates in Mincer. Haml Coffee templates have the extension\n`.jst.hamlc`.\n\nIf `jade` Node module is available to your application, you can use _Jade_\ntemplates in Mincer. Jade templates have the extension `.jst.jade`. To use\ncompiled templates you will need to require Jade [runtime][jade-runtime] before\ncalling renderer functions.\n\n[hamlc]:         https://github.com/netzpirat/haml-coffee\n[jade]:          https://github.com/visionmedia/jade\n[jade-runtime]:  https://github.com/visionmedia/jade/blob/master/runtime.js\n\n\n### Invoking JavaScript with EJS\n\n**Note** see macros description for more convenient alternative.\n\nMincer provides an EJS engine for preprocessing assets using\nembedded JavaScript code. Append `.ejs` to a CSS or JavaScript asset's\nfilename to enable the EJS engine.\n\nYou will need `ejs` Node module available to your application.\n\n**Note**: Mincer processes multiple engine extensions in order from\n  right to left, so you can use multiple engines with a single\n  asset. For example, to have a CoffeeScript asset that is first\n  preprocessed with EJS, use the extension `.js.coffee.ejs`.\n\nJavaScript code embedded in an asset is evaluated in the context of a\n`Mincer.Context` instance for the given asset. Common uses for EJS include:\n\n- embedding another asset as a Base64-encoded `data:` URI with the\n  `asset_data_uri` helper\n- inserting the URL to another asset, such as with the `asset_path`\n  helper (you must register your own helper for this purpose, but\n  it's dead simple).\n- embedding other application resources, such as a localized string\n  database, in a JavaScript asset via JSON\n- embedding version constants loaded from another file\n\n\n### Using helpers\n\nMincer provides an easy way to add your own helpers for engines:\n\n``` javascript\nenvironment.registerHelper('version', function () {\n  return require(__dirname, '/package.json').version;\n});\n```\n\nNow, you can call that helper with EJS like this:\n\n``` javascript\nvar APP = window.APP = {version: '<%= version() %>'};\n```\n\n**NOTICE** Helpers currently work for EJS and Stylus only. So to use them with\nLess you will need to add EJS engine as well:\n\n``` css\n// file: foobar.less.ejs\n.btn {\n  background: url('<%= asset_path('bg.png') %>');\n}\n```\n\n### Macros\n\nThis feature is designed as simple alternative to EJS, that does not requires\nadditional extention and does not break language syntax. When enabled, any\n`'$$ expression $$'` or `\"$$ expression $$\"` pattern will be replaced with\nevaluated expression value. In expression you can write JS code and use\nregistered helpers. Macros are off by default. You should enable those for\nparticular extentions:\n\n```javascript\nMincer.MacroProcessor.configure(['.js', '.css']);\n```\n\n\n## Managing and Bundling Dependencies\n\nYou can create *asset bundles*Â -- ordered concatenations of asset\nsource files -- by specifying dependencies in a special comment syntax\nat the top of each source file.\n\nMincer reads these comments, called *directives*, and processes\nthem to recursively build a dependency graph. When you request an\nasset with dependencies, the dependencies will be included in order at\nthe top of the file.\n\n\n### The Directive Processor\n\nMincer runs the *directive processor* on each CSS and JavaScript\nsource file. The directive processor scans for comment lines beginning\nwith `=` in comment blocks at the top of the file.\n\n    //= require jquery\n    //= require jquery-ui\n    //= require backbone\n    //= require_tree .\n\nThe first word immediately following `=` specifies the directive\nname. Any words following the directive name are treated as\narguments. Arguments may be placed in single or double quotes if they\ncontain spaces, similar to commands in the Unix shell.\n\n**Note**: Non-directive comment lines will be preserved in the final\n  asset, but directive comments are stripped after\n  processing. Mincer will not look for directives in comment blocks\n  that occur after the first line of code.\n\n\n#### Supported Comment Types\n\nThe directive processor understands comment blocks in three formats:\n\n    /* Multi-line comment blocks (CSS, Stylus, JavaScript)\n     *= require foo\n     */\n\n    // Single-line comment blocks (Stylus, JavaScript)\n    //= require foo\n\n    # Single-line comment blocks (CoffeeScript)\n    #= require foo\n\n\n### Mincer Directives\n\nYou can use the following directives to declare dependencies in asset\nsource files.\n\nFor directives that take a *path* argument, you may specify either a\nlogical path or a relative path. Relative paths begin with `./` and\nreference files relative to the location of the current file.\n\n\n#### The `require` Directive ###\n\n`require` *path* inserts the contents of the asset source file\nspecified by *path*. If the file is required multiple times, it will\nappear in the bundle only once.\n\n\n#### The `include` Directive ###\n\n`include` *path* works like `require`, but inserts the contents of the\nspecified source file even if it has already been included or\nrequired.\n\n\n#### The `require_directory` Directive ###\n\n`require_directory` *path* requires all source files of the same\nformat in the directory specified by *path*. Files are required in\nalphabetical order.\n\n\n#### The `require_tree` Directive ###\n\n`require_tree` *path* works like `require_directory`, but operates\nrecursively to require all files in all subdirectories of the\ndirectory specified by *path*.\n\n\n#### The `require_self` Directive ###\n\n`require_self` tells Mincer to insert the body of the current\nsource file before any subsequent `require` or `include` directives.\n\n\n#### The `depend_on` Directive ###\n\n`depend_on` *path* declares a dependency on the given *path* without\nincluding it in the bundle. This is useful when you need to expire an\nasset's cache in response to a change in another file.\n\n\n#### The `stub` Directive ###\n\n`stub` *path* allows dependency to be excluded from the asset bundle.\nThe *path* must be a valid asset and may or may not already be part\nof the bundle. Once stubbed, it is blacklisted and can't be brought\nback by any other `require`.\n\n\n## Credits\n\nGreat thanks to [Sam Stephenson][sam] and [Joshua Peek][josh] for the Sprockets,\nthe most awesome and powerfull web assets processor I ever used, and which\nbecame a great source of inspiration (and model of almost all logic behind\nMincer). Special thanks to Joshua for his assistance in hacking into Sprockets\nsources.\n\n[sam]:  https://github.com/sstephenson\n[josh]: https://github.com/josh\n\n\n## Author\n\n[Aleksey V Zapparov][github] (follow [@zapparov][twitter] on twitter).\n\n[github]:   https://github.com/ixti\n[twitter]:  https://twitter.com/zapparov\n\n\n## License\n\nCopyright (c) 2012 [Vitaly Puzrin](https://github.com/puzrin)\n\nReleased under the MIT license. See [LICENSE][license] for details.\n\n[license]:  https://raw.github.com/nodeca/mincer/master/LICENSE\n",
  "readmeFilename": "README.md",
  "_id": "mincer@1.2.2",
  "dist": {
    "shasum": "74e3d029ed3520699df000ef2c1fa3dcd30ce163"
  },
  "_from": "mincer@1.2.2",
  "_resolved": "https://registry.npmjs.org/mincer/-/mincer-1.2.2.tgz"
}
